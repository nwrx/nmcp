use crate::{Controller, ControllerOptions, MCPPool, MCPServer};
use anyhow::{anyhow, Result};
use k8s_openapi::api::core::v1::Namespace;
use k8s_openapi::apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition;
use kube::api::{DeleteParams, PostParams};
use kube::{Api, Client, CustomResourceExt};
use rand::{distr::Alphanumeric, Rng};
use std::future::Future;
use tokio::time::sleep;

/// Default path to the kubeconfig file generated by docker-compose if KUBECONFIG env var is not set
static DEFAULT_KUBECONFIG_PATH: &str =
    "/home/shorwood/Workspaces/nmcp/k3s/kubeconfig/kubeconfig.yaml";

#[derive(Clone)]
pub struct TestContext {
    controller: Controller,
}

impl TestContext {
    pub async fn new() -> Self {
        // --- Create a random namespace name.
        let namespace_name = rand::rng()
            .sample_iter(&Alphanumeric)
            .take(10)
            .map(|c| c.to_ascii_lowercase())
            .map(char::from)
            .collect::<String>()
            .to_string();

        // --- Create the controller options.
        let controller_options = ControllerOptions {
            namespace: namespace_name.clone(),
            kubeconfig: Some(DEFAULT_KUBECONFIG_PATH.into()),
            ..Default::default()
        };

        // --- Create the controller.
        let controller = match Controller::new(&controller_options).await {
            Ok(controller) => controller,
            Err(e) => panic!("Failed to create controller: {e}"),
        };
        Self { controller }
    }

    pub fn get_client(&self) -> Client {
        self.controller.get_client()
    }

    pub fn get_namespace(&self) -> String {
        self.controller.get_namespace()
    }

    /// Creates the MCPPool CRD in the Kubernetes cluster
    pub async fn create_crd_servers(&self) -> Result<()> {
        let client = self.get_client();
        let crd: CustomResourceDefinition = MCPServer::crd();
        let crds_api: Api<CustomResourceDefinition> = Api::all(client);
        let crd_name = MCPServer::crd_name();
        match crds_api.get(crd_name).await {
            Ok(_) => Ok(()),
            Err(_) => {
                // Create the CRD
                crds_api.create(&PostParams::default(), &crd).await?;
                Ok(())
            }
        }
    }

    /// Creates the MCPPool CRD in the Kubernetes cluster
    pub async fn create_crd_pools(&self) -> Result<()> {
        let client = self.get_client();
        let crd: CustomResourceDefinition = MCPPool::crd();
        let crds_api: Api<CustomResourceDefinition> = Api::all(client);
        let crd_name = MCPPool::crd_name();
        match crds_api.get(crd_name).await {
            Ok(_) => Ok(()),
            Err(_) => {
                // Create the CRD
                crds_api.create(&PostParams::default(), &crd).await?;
                Ok(())
            }
        }
    }

    /// Deletes the MCPServer CRD from the Kubernetes cluster
    pub async fn delete_crd_servers(&self) -> Result<()> {
        let client = self.get_client();
        let crds_api: Api<CustomResourceDefinition> = Api::all(client);
        let crd_name = MCPServer::crd_name();
        match crds_api.get(crd_name).await {
            Ok(_) => {
                crds_api.delete(crd_name, &DeleteParams::default()).await?;
                sleep(std::time::Duration::from_millis(10)).await;
                Ok(())
            }
            Err(_) => Ok(()),
        }
    }

    /// Deletes the MCPPool CRD from the Kubernetes cluster
    pub async fn delete_crd_pools(&self) -> Result<()> {
        let client = self.get_client();
        let crds_api: Api<CustomResourceDefinition> = Api::all(client);
        let crd_name = MCPPool::crd_name();
        match crds_api.get(crd_name).await {
            Ok(_) => {
                crds_api.delete(crd_name, &DeleteParams::default()).await?;
                sleep(std::time::Duration::from_millis(10)).await;
                Ok(())
            }
            Err(_) => Ok(()),
        }
    }

    /// Create a test namespace and run the test function within that namespace.
    /// The namespace will be deleted after the test function completes.
    pub async fn run<F, Fut, T>(&self, test_fn: F) -> Result<T>
    where
        F: FnOnce(Controller) -> Fut,
        Fut: Future<Output = Result<T>>,
    {
        // --- Create a new namespace for the test.
        let client = self.get_client();
        let namespace_name = self.get_namespace();
        let namespace_api = Api::<Namespace>::all(client.clone());
        let mut namespace = Namespace::default();
        namespace.metadata.name = Some(namespace_name.clone());
        let create_params = PostParams::default();
        namespace_api
            .create(&create_params, &namespace)
            .await
            .map_err(|e| anyhow!("Failed to create namespace: {}", e))?;

        // --- Clone the context and pass ownership to the test function
        let result = test_fn(self.controller.clone()).await?;

        // --- Clean up by deleting the namespace.
        let delete_params = DeleteParams::default();
        namespace_api
            .delete(&namespace_name, &delete_params)
            .await?;

        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Tests that the namespace is not created before the test function is run.
    #[tokio::test]
    async fn test_run_no_namespace() {
        let result = TestContext::new().await;
        let namespace = result.get_namespace();
        let client = result.get_client();
        let namespace_api = Api::<Namespace>::all(client);
        let ns = namespace_api.get(&namespace).await;
        assert!(ns.is_err(), "Namespace should not exist before test");
    }

    /// Tests the creation of a namespace and verifies its existence.
    #[tokio::test]
    async fn test_run_create_namespace() {
        let result = TestContext::new()
            .await
            .run(|controller| async move {
                let client = controller.get_client();
                let namespace = controller.get_namespace();
                let namespace_api = Api::<Namespace>::all(client);
                let ns = namespace_api.get(&namespace).await?;
                assert_eq!(ns.metadata.name, Some(namespace));
                Ok(())
            })
            .await;
        assert!(result.is_ok());
    }

    /// Tests the deletion of a namespace after running a test function.
    #[tokio::test]
    async fn test_run_namespace_teardown() {
        let context = TestContext::new().await;
        let namespace = context.get_namespace();
        context.run(|_| async move { Ok(()) }).await.unwrap();
        let client = context.get_client();
        let phase = Api::<Namespace>::all(client)
            .get(&namespace)
            .await
            .unwrap()
            .status
            .unwrap()
            .phase
            .unwrap();

        // --- Check if the namespace is in the "Terminating" phase.
        assert_eq!(
            phase, "Terminating",
            "Namespace was not deleted successfully"
        );
    }

    /// Tests the creation of the MCPPool CRD and verifies its existence.
    #[tokio::test]
    async fn test_create_crd_servers() {
        let context = TestContext::new().await;
        let result = context.create_crd_servers().await;
        assert!(result.is_ok());
    }

    /// Tests the creation of the MCPPool CRD and verifies its existence.
    #[tokio::test]
    async fn test_create_crd_pools() {
        let context = TestContext::new().await;
        let result = context.create_crd_pools().await;
        assert!(result.is_ok());
    }
}
